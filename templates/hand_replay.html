<div class="space-y-6" id="hand-replay-container">
    <!-- Replay Controls -->
    <div class="bg-gray-100 rounded-lg p-4">
        <div class="flex items-center justify-between mb-4">
            <h4 class="font-bold text-lg">Hand Replay</h4>
            <div class="text-sm text-gray-600">
                Step <span id="current-step">0</span> of <span id="total-steps">0</span>
            </div>
        </div>
        
        <!-- Control Buttons -->
        <div class="flex items-center justify-center space-x-4">
            <button id="first-btn" class="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300" disabled>
                ⏮️ First
            </button>
            <button id="prev-btn" class="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300" disabled>
                ⏪ Previous
            </button>
            <button id="play-pause-btn" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600">
                ▶️ Play
            </button>
            <button id="next-btn" class="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                ⏩ Next
            </button>
            <button id="last-btn" class="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                ⏭️ Last
            </button>
        </div>
        
        <!-- Speed Control -->
        <div class="flex items-center justify-center mt-4 space-x-2">
            <label class="text-sm text-gray-600">Speed:</label>
            <select id="speed-select" class="px-2 py-1 border rounded">
                <option value="2000">Slow (2s)</option>
                <option value="1000" selected>Normal (1s)</option>
                <option value="500">Fast (0.5s)</option>
            </select>
        </div>
        
        <!-- Progress Bar -->
        <div class="mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="progress-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
    </div>


    <!-- Poker Table Visual -->
    <div class="relative p-8 min-h-96">
        <!-- Poker Table Surface (Elliptical) -->
        <div class="poker-table-container relative mx-auto" style="width: 600px; height: 400px;">
            <!-- Table Felt (Elliptical shape) -->
            <div class="poker-table-felt absolute inset-0 rounded-full shadow-2xl" 
                 style="background: radial-gradient(ellipse, #0f5132 0%, #198754 30%, #0f5132 100%); 
                        border: 8px solid #8b4513; 
                        box-shadow: inset 0 0 50px rgba(0,0,0,0.3), 0 10px 30px rgba(0,0,0,0.5);">
            </div>
            
            <!-- Table Edge (Inner border) -->
            <div class="absolute inset-2 rounded-full border-4 border-yellow-600 opacity-60"></div>
            
            <!-- Board Cards -->
            <div class="absolute top-16 left-1/2 transform -translate-x-1/2">
                <div class="flex space-x-2" id="board-cards">
                    <!-- Board cards will be populated here -->
                </div>
            </div>
            
            <!-- Pot Display -->
            <div class="absolute top-40 left-1/2 transform -translate-x-1/2 bg-white rounded-lg px-4 py-2 shadow-lg">
                <div class="text-center">
                    <div class="text-xs text-gray-600">Pot</div>
                    <div class="font-bold text-lg">$<span id="pot-display">0</span></div>
                </div>
            </div>
            
            <!-- Players positioned around the elliptical table -->
            <div id="players-container" class="absolute inset-0">
                <!-- Players will be positioned here -->
            </div>
        </div>
    </div>

</div>

<script>
class HandReplay {
    constructor(playId) {
        console.log(`HandReplay constructor called with playId: ${playId}`);
        this.playId = playId;
        this.steps = [];
        this.currentStep = 0;
        this.isPlaying = false;
        this.playInterval = null;
        this.speed = 1000; // 1 second default
        
        console.log('Initializing elements...');
        this.initializeElements();
        console.log('Binding events...');
        this.bindEvents();
        console.log('Loading replay data...');
        this.loadReplayData();
    }
    
    initializeElements() {
        this.firstBtn = document.getElementById('first-btn');
        this.prevBtn = document.getElementById('prev-btn');
        this.playPauseBtn = document.getElementById('play-pause-btn');
        this.nextBtn = document.getElementById('next-btn');
        this.lastBtn = document.getElementById('last-btn');
        this.speedSelect = document.getElementById('speed-select');
        this.progressBar = document.getElementById('progress-bar');
        this.currentStepSpan = document.getElementById('current-step');
        this.totalStepsSpan = document.getElementById('total-steps');
        this.potDisplay = document.getElementById('pot-display');
        this.boardCards = document.getElementById('board-cards');
        this.playersContainer = document.getElementById('players-container');
    }
    
    bindEvents() {
        this.firstBtn.addEventListener('click', () => this.goToStep(0));
        this.prevBtn.addEventListener('click', () => this.previousStep());
        this.playPauseBtn.addEventListener('click', () => this.togglePlay());
        this.nextBtn.addEventListener('click', () => this.nextStep());
        this.lastBtn.addEventListener('click', () => this.goToStep(this.steps.length - 1));
        this.speedSelect.addEventListener('change', (e) => {
            this.speed = parseInt(e.target.value);
        });
    }
    
    async loadReplayData() {
        try {
            console.log(`Loading replay data for play_id: ${this.playId}`);
            
            const response = await fetch(`/api/hands/${this.playId}/replay`);
            console.log('Response status:', response.status);
            
            const data = await response.json();
            console.log('Replay data loaded:', data);
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            this.steps = data.steps;
            this.totalStepsSpan.textContent = this.steps.length;
            console.log(`Loaded ${this.steps.length} steps`);
            this.updateDisplay();
        } catch (error) {
            console.error('Error loading replay data:', error);
        }
    }
    
    goToStep(step) {
        if (step >= 0 && step < this.steps.length) {
            this.currentStep = step;
            this.updateDisplay();
        }
    }
    
    nextStep() {
        if (this.currentStep < this.steps.length - 1) {
            this.currentStep++;
            this.updateDisplay();
        } else if (this.isPlaying) {
            this.pause();
        }
    }
    
    previousStep() {
        if (this.currentStep > 0) {
            this.currentStep--;
            this.updateDisplay();
        }
    }
    
    togglePlay() {
        if (this.isPlaying) {
            this.pause();
        } else {
            this.play();
        }
    }
    
    play() {
        this.isPlaying = true;
        this.playPauseBtn.textContent = '⏸️ Pause';
        this.playInterval = setInterval(() => {
            this.nextStep();
        }, this.speed);
    }
    
    pause() {
        this.isPlaying = false;
        this.playPauseBtn.textContent = '▶️ Play';
        if (this.playInterval) {
            clearInterval(this.playInterval);
            this.playInterval = null;
        }
    }
    
    updateDisplay() {
        if (!this.steps.length) return;
        
        const step = this.steps[this.currentStep];
        
        // Update step counter
        this.currentStepSpan.textContent = this.currentStep + 1;
        
        // Update progress bar
        const progress = ((this.currentStep) / (this.steps.length - 1)) * 100;
        this.progressBar.style.width = `${progress}%`;
        
        // Update pot display
        this.potDisplay.textContent = step.pot_size;
        
        // Update board cards
        this.updateBoardCards(step.board);
        
        // Update players
        this.updatePlayers(step.players);
        
        // Update button states
        this.firstBtn.disabled = this.currentStep === 0;
        this.prevBtn.disabled = this.currentStep === 0;
        this.nextBtn.disabled = this.currentStep === this.steps.length - 1;
        this.lastBtn.disabled = this.currentStep === this.steps.length - 1;
    }
    
    updateBoardCards(board) {
        this.boardCards.innerHTML = '';
        
        // Always show 5 card slots
        for (let i = 0; i < 5; i++) {
            const cardElement = document.createElement('div');
            
            if (i < board.length && board[i]) {
                // Show actual card
                cardElement.className = 'bg-white border-2 border-gray-800 rounded-lg w-12 h-16 flex items-center justify-center font-bold text-sm shadow-md';
                cardElement.textContent = board[i];
            } else {
                // Show empty slot
                cardElement.className = 'bg-gray-200 border-2 border-gray-300 rounded-lg w-12 h-16 flex items-center justify-center text-gray-400 text-xs';
                cardElement.textContent = '?';
            }
            
            this.boardCards.appendChild(cardElement);
        }
    }
    
    updatePlayers(players) {
        // Position players around the elliptical table
        this.playersContainer.innerHTML = '';
        
        // Table dimensions (matching CSS)
        const tableWidth = 600;
        const tableHeight = 400;
        const centerX = tableWidth / 2;
        const centerY = tableHeight / 2;
        
        // Ellipse parameters for player positioning (outside the felt with more spacing)
        const radiusX = (tableWidth / 2) + 20; // More space for player boxes
        const radiusY = (tableHeight / 2) + 15;
        
        players.forEach((player, index) => {
            // Calculate angle around the ellipse (starting from bottom, going counter-clockwise)
            const angleOffset = -Math.PI / 2; // Start from bottom (6 o'clock)
            const angle = angleOffset + (index * 2 * Math.PI) / players.length;
            
            // Calculate position on ellipse
            const x = centerX + radiusX * Math.cos(angle);
            const y = centerY + radiusY * Math.sin(angle);
            
            const playerElement = document.createElement('div');
            playerElement.className = `absolute transform -translate-x-1/2 -translate-y-1/2 ${player.is_active ? 'bg-white' : 'bg-gray-200'} rounded-lg p-2 border-2 ${player.is_active ? 'border-green-400' : 'border-gray-300'} text-center shadow-lg`;
            playerElement.style.left = `${x}px`;
            playerElement.style.top = `${y}px`;
            playerElement.style.zIndex = '10';
            playerElement.style.minWidth = '120px';
            
            // Parse hole cards for horizontal display
            let holeCardsHtml = '';
            if (player.hole_cards) {
                const cards = player.hole_cards.match(/.{1,2}/g) || [];
                holeCardsHtml = `
                    <div class="flex justify-center space-x-1 mb-2">
                        ${cards.map(card => `
                            <div class="bg-white border border-gray-800 rounded text-xs px-1 py-0.5 font-mono text-black shadow-sm" style="min-width: 20px;">
                                ${card}
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            playerElement.innerHTML = `
                <div class="text-xs font-bold mb-1">${player.name}</div>
                <div class="text-xs text-gray-600 mb-1">${player.position}</div>
                ${holeCardsHtml}
                <div class="text-xs font-bold text-green-600">$${player.stack}</div>
                ${player.current_bet > 0 ? `<div class="text-xs text-red-600 font-bold mt-1">Bet: $${player.current_bet}</div>` : ''}
            `;
            
            this.playersContainer.appendChild(playerElement);
        });
    }
}

// Global function to initialize replay
window.initHandReplay = function(playId) {
    console.log(`initHandReplay called with playId: ${playId}`);
    // Clean up any existing replay instance
    if (window.currentReplay) {
        if (window.currentReplay.playInterval) {
            clearInterval(window.currentReplay.playInterval);
        }
        window.currentReplay = null;
    }
    
    // Create new replay instance
    setTimeout(() => {
        console.log('Creating new HandReplay instance');
        window.currentReplay = new HandReplay(playId);
    }, 100);
};

// Auto-initialize if template is loaded with play_id
(function() {
    const playId = '{{ hand.play_id if hand else "" }}';
    if (playId) {
        console.log(`Auto-initializing replay for playId: ${playId}`);
        // Wait for DOM to be ready, then initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(() => {
                    window.initHandReplay(playId);
                }, 200);
            });
        } else {
            setTimeout(() => {
                window.initHandReplay(playId);
            }, 200);
        }
    }
})();
</script>